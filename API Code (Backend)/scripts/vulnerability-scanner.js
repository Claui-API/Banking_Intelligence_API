// scripts/vulnerability-scanner.js
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const logger = require('../src/utils/logger');
const axios = require('axios');

/**
 * Vulnerability Scanner
 * This script scans assets for vulnerabilities and generates reports
 */

// Configuration
const CONFIG = {
	outputDir: path.join(__dirname, '..', 'security-reports'),
	vulnerabilityReportFile: 'vulnerability-report.json',
	assetInventoryFile: 'network-assets.json',
	npmAuditEnabled: true,
	dependencyCheckEnabled: true,
	dockerScanEnabled: true
};

// Ensure output directory exists
if (!fs.existsSync(CONFIG.outputDir)) {
	fs.mkdirSync(CONFIG.outputDir, { recursive: true });
}

// Vulnerability report file path
const vulnerabilityReportPath = path.join(CONFIG.outputDir, CONFIG.vulnerabilityReportFile);
const assetInventoryPath = path.join(CONFIG.outputDir, CONFIG.assetInventoryFile);

// Load existing vulnerability report if available
let vulnerabilityReport = {
	lastScan: null,
	findings: [],
	summary: {
		total: 0,
		critical: 0,
		high: 0,
		medium: 0,
		low: 0
	}
};

if (fs.existsSync(vulnerabilityReportPath)) {
	try {
		vulnerabilityReport = JSON.parse(fs.readFileSync(vulnerabilityReportPath, 'utf8'));
		logger.info(`Loaded existing vulnerability report with ${vulnerabilityReport.findings.length} findings`);
	} catch (error) {
		logger.error('Error loading vulnerability report:', error);
		vulnerabilityReport = { lastScan: null, findings: [], summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 } };
	}
}

/**
 * Run a scan of NPM dependencies for vulnerabilities
 */
async function scanNpmDependencies() {
	if (!CONFIG.npmAuditEnabled) {
		logger.info('NPM audit is disabled');
		return [];
	}

	logger.info('Scanning NPM dependencies for vulnerabilities...');
	const findings = [];

	try {
		// Check if npm is installed
		try {
			execSync('npm --version', { stdio: 'ignore' });
		} catch (error) {
			logger.error('NPM is not installed or not in PATH');
			return [];
		}

		// Run npm audit
		try {
			// Run audit and capture output in JSON format
			const auditResult = execSync('npm audit --json', { encoding: 'utf8' });
			const auditData = JSON.parse(auditResult);

			if (auditData.vulnerabilities) {
				// Process each vulnerability
				Object.entries(auditData.vulnerabilities).forEach(([name, vuln]) => {
					// Map severity to a numeric value for consistent sorting
					const severityMap = { critical: 4, high: 3, moderate: 2, low: 1 };
					const severityScore = severityMap[vuln.severity] || 0;

					findings.push({
						id: `npm-${vuln.name}-${vuln.source || 'unknown'}-${Date.now()}`,
						assetId: 'banking-api-dependencies',
						assetType: 'npm-dependency',
						name: `Vulnerable Dependency: ${vuln.name}`,
						description: vuln.overview || 'No details available',
						severity: vuln.severity,
						severityScore,
						package: vuln.name,
						fixedIn: vuln.fixAvailable ? (vuln.fixAvailable.version || 'available') : 'not available',
						discoveredAt: new Date().toISOString(),
						status: 'open',
						recommendation: vuln.recommendation || 'Update the package to the latest version'
					});
				});
			}

			logger.info(`NPM audit discovered ${findings.length} vulnerabilities`);
		} catch (error) {
			if (error.stdout) {
				try {
					// Try to parse JSON output even if command exited with error code
					const auditData = JSON.parse(error.stdout);

					if (auditData.vulnerabilities) {
						// Process each vulnerability
						Object.entries(auditData.vulnerabilities).forEach(([name, vuln]) => {
							const severityMap = { critical: 4, high: 3, moderate: 2, low: 1 };
							const severityScore = severityMap[vuln.severity] || 0;

							findings.push({
								id: `npm-${vuln.name}-${vuln.source || 'unknown'}-${Date.now()}`,
								assetId: 'banking-api-dependencies',
								assetType: 'npm-dependency',
								name: `Vulnerable Dependency: ${vuln.name}`,
								description: vuln.overview || 'No details available',
								severity: vuln.severity,
								severityScore,
								package: vuln.name,
								fixedIn: vuln.fixAvailable ? (vuln.fixAvailable.version || 'available') : 'not available',
								discoveredAt: new Date().toISOString(),
								status: 'open',
								recommendation: vuln.recommendation || 'Update the package to the latest version'
							});
						});

						logger.info(`NPM audit discovered ${findings.length} vulnerabilities (with non-zero exit code)`);
					}
				} catch (parseError) {
					logger.error('Error parsing NPM audit output:', parseError);
				}
			} else {
				logger.error('Error running NPM audit:', error);
			}
		}
	} catch (error) {
		logger.error('Error scanning NPM dependencies:', error);
	}

	return findings;
}

/**
 * Run OWASP Dependency Check for vulnerability scanning
 */
async function runDependencyCheck() {
	if (!CONFIG.dependencyCheckEnabled) {
		logger.info('Dependency Check is disabled');
		return [];
	}

	logger.info('Running OWASP Dependency Check...');
	const findings = [];

	try {
		// Check if dependency-check script exists
		const dependencyCheckScript = path.join(__dirname, 'dependency-check.sh');

		if (!fs.existsSync(dependencyCheckScript)) {
			logger.info('Dependency Check script not found, creating it...');

			// Create the dependency-check.sh script
			const scriptContent = `#!/bin/bash
VERSION="latest"
DATA_DIRECTORY="$HOME/.dependency-check/data"
REPORT_DIRECTORY="${CONFIG.outputDir}"

if [ ! -d "$DATA_DIRECTORY" ]; then
  mkdir -p "$DATA_DIRECTORY"
fi

if [ ! -d "$REPORT_DIRECTORY" ]; then
  mkdir -p "$REPORT_DIRECTORY"
fi

docker run --rm \
  -v $(pwd):/src \
  -v "$DATA_DIRECTORY":/usr/share/dependency-check/data \
  -v "$REPORT_DIRECTORY":/report \
  owasp/dependency-check:$VERSION \
  --scan /src \
  --format "JSON" \
  --out /report/dependency-check-report.json
`;

			fs.writeFileSync(dependencyCheckScript, scriptContent, { mode: 0o755 });
			logger.info('Dependency Check script created');
		}

		// Run the dependency check
		logger.info('Running Dependency Check (this may take a while)...');
		execSync(dependencyCheckScript, { stdio: 'inherit' });

		// Parse the results
		const reportFile = path.join(CONFIG.outputDir, 'dependency-check-report.json');

		if (fs.existsSync(reportFile)) {
			const report = JSON.parse(fs.readFileSync(reportFile, 'utf8'));

			if (report.dependencies) {
				report.dependencies.forEach(dependency => {
					if (dependency.vulnerabilities && dependency.vulnerabilities.length > 0) {
						dependency.vulnerabilities.forEach(vuln => {
							const severityMap = { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 };
							const severity = vuln.cvssv3 ? vuln.cvssv3.baseSeverity : (vuln.cvssv2 ? vuln.cvssv2.severity : 'UNKNOWN');
							const severityScore = severityMap[severity] || 0;

							findings.push({
								id: `owasp-${vuln.name}-${Date.now()}`,
								assetId: 'banking-api-dependencies',
								assetType: 'application-dependency',
								name: `Vulnerable Dependency: ${dependency.fileName}`,
								description: vuln.description || 'No details available',
								severity: severity.toLowerCase(),
								severityScore,
								package: dependency.fileName,
								cve: vuln.name,
								discoveredAt: new Date().toISOString(),
								status: 'open',
								recommendation: 'Update the dependency to a non-vulnerable version'
							});
						});
					}
				});
			}

			logger.info(`OWASP Dependency Check discovered ${findings.length} vulnerabilities`);
		} else {
			logger.warn('Dependency Check report not found');
		}
	} catch (error) {
		logger.error('Error running Dependency Check:', error);
	}

	return findings;
}

/**
 * Scan Docker images for vulnerabilities
 */
async function scanDockerImages() {
	if (!CONFIG.dockerScanEnabled) {
		logger.info('Docker scan is disabled');
		return [];
	}

	logger.info('Scanning Docker images for vulnerabilities...');
	const findings = [];

	try {
		// Check if Docker is installed
		try {
			execSync('docker --version', { stdio: 'ignore' });
		} catch (error) {
			logger.error('Docker is not installed or not in PATH');
			return [];
		}

		// List Docker images
		const imageListOutput = execSync('docker image ls --format "{{.Repository}}:{{.Tag}}"', { encoding: 'utf8' });
		const images = imageListOutput.trim().split('\n').filter(image => !image.startsWith('<none>'));

		logger.info(`Found ${images.length} Docker images to scan`);

		// Scan each image
		for (const image of images) {
			logger.info(`Scanning Docker image: ${image}`);

			try {
				// Run docker scan (using Snyk, which needs to be enabled)
				const scanOutput = execSync(`docker scan --json ${image}`, { encoding: 'utf8' });
				const scanData = JSON.parse(scanOutput);

				if (scanData.vulnerabilities) {
					scanData.vulnerabilities.forEach(vuln => {
						const severityMap = { critical: 4, high: 3, medium: 2, low: 1 };
						const severityScore = severityMap[vuln.severity] || 0;

						findings.push({
							id: `docker-${vuln.id}-${Date.now()}`,
							assetId: `docker-image-${image.replace(/[^a-zA-Z0-9]/g, '-')}`,
							assetType: 'docker-image',
							name: `Docker Image Vulnerability: ${image}`,
							description: vuln.title || 'No details available',
							severity: vuln.severity,
							severityScore,
							package: vuln.packageName,
							version: vuln.version,
							fixedIn: vuln.fixedIn || 'not available',
							discoveredAt: new Date().toISOString(),
							status: 'open',
							recommendation: vuln.description || 'Update the affected package or rebuild the Docker image'
						});
					});
				}

				logger.info(`Docker scan discovered ${scanData.vulnerabilities ? scanData.vulnerabilities.length : 0} vulnerabilities in ${image}`);
			} catch (error) {
				logger.error(`Error scanning Docker image ${image}:`, error);
			}
		}
	} catch (error) {
		logger.error('Error scanning Docker images:', error);
	}

	return findings;
}

/**
 * Run a scan of server endpoints
 */
async function scanServerEndpoints() {
	logger.info('Scanning server endpoints for vulnerabilities...');
	const findings = [];

	try {
		// Load asset inventory to get servers to scan
		if (!fs.existsSync(assetInventoryPath)) {
			logger.warn('Asset inventory file not found. Run network-endpoint-discovery.js first.');
			return [];
		}

		const assetInventory = JSON.parse(fs.readFileSync(assetInventoryPath, 'utf8'));
		const servers = Object.values(assetInventory.assets).filter(
			asset => ['ec2-instance', 'server', 'vm'].includes(asset.type) && asset.active !== false
		);

		logger.info(`Found ${servers.length} servers to scan`);

		for (const server of servers) {
			const ip = server.ip?.public || server.ip?.internal;

			if (!ip) {
				logger.warn(`Server ${server.id} has no IP address to scan`);
				continue;
			}

			logger.info(`Scanning server: ${server.name} (${ip})`);

			try {
				// Run a quick nmap vulnerability scan
				const scanOutput = execSync(`nmap -sV --script vuln ${ip}`, { encoding: 'utf8' });

				// Parse the scan output (simple parsing, can be improved)
				const vulnerabilityLines = scanOutput
					.split('\n')
					.filter(line => line.includes('VULNERABLE') || line.includes('CVE-'));

				vulnerabilityLines.forEach(line => {
					// Extract CVE if available
					const cveMatch = line.match(/CVE-\d{4}-\d+/g);
					const cve = cveMatch ? cveMatch[0] : null;

					// Extract basic info
					const vulnMatch = line.match(/^(\||\+)_\s+(.*?)(?:\s+\((CVE-\d{4}-\d+)\))?/);
					const name = vulnMatch ? vulnMatch[2] : line;

					findings.push({
						id: `server-${server.id}-${cve || Date.now()}`,
						assetId: server.id,
						assetType: server.type,
						name: `Server Vulnerability: ${name}`,
						description: line,
						severity: line.includes('CRITICAL') ? 'critical' :
							line.includes('HIGH') ? 'high' :
								line.includes('MEDIUM') ? 'medium' : 'low',
						severityScore: line.includes('CRITICAL') ? 4 :
							line.includes('HIGH') ? 3 :
								line.includes('MEDIUM') ? 2 : 1,
						cve,
						discoveredAt: new Date().toISOString(),
						status: 'open',
						recommendation: 'Update the affected service or apply security patches'
					});
				});

				logger.info(`Server scan discovered ${vulnerabilityLines.length} potential vulnerabilities on ${server.name}`);
			} catch (error) {
				logger.error(`Error scanning server ${server.name}:`, error);
			}
		}
	} catch (error) {
		logger.error('Error scanning server endpoints:', error);
	}

	return findings;
}

/**
 * Run a comprehensive vulnerability scan
 */
async function runVulnerabilityScan() {
	const startTime = Date.now();
	logger.info('Starting vulnerability scan...');

	try {
		// Clear previous findings
		const previousFindings = vulnerabilityReport.findings;
		vulnerabilityReport.findings = [];

		// Run NPM dependencies scan
		const npmFindings = await scanNpmDependencies();
		vulnerabilityReport.findings.push(...npmFindings);

		// Run OWASP Dependency Check
		const dependencyCheckFindings = await runDependencyCheck();
		vulnerabilityReport.findings.push(...dependencyCheckFindings);

		// Run Docker image scan
		const dockerFindings = await scanDockerImages();
		vulnerabilityReport.findings.push(...dockerFindings);

		// Run server endpoint scan
		const serverFindings = await scanServerEndpoints();
		vulnerabilityReport.findings.push(...serverFindings);

		// Update findings that were previously discovered
		vulnerabilityReport.findings.forEach(finding => {
			const previousFinding = previousFindings.find(prev =>
				prev.assetId === finding.assetId &&
				prev.name === finding.name &&
				prev.package === finding.package
			);

			if (previousFinding) {
				finding.status = previousFinding.status;
				finding.firstDiscoveredAt = previousFinding.firstDiscoveredAt || previousFinding.discoveredAt;
				finding.notes = previousFinding.notes;
			} else {
				finding.firstDiscoveredAt = finding.discoveredAt;
			}
		});

		// Update summary
		vulnerabilityReport.summary = {
			total: vulnerabilityReport.findings.length,
			critical: vulnerabilityReport.findings.filter(f => f.severity === 'critical').length,
			high: vulnerabilityReport.findings.filter(f => f.severity === 'high').length,
			medium: vulnerabilityReport.findings.filter(f => f.severity === 'medium' || f.severity === 'moderate').length,
			low: vulnerabilityReport.findings.filter(f => f.severity === 'low').length,
			open: vulnerabilityReport.findings.filter(f => f.status === 'open').length,
			fixed: vulnerabilityReport.findings.filter(f => f.status === 'fixed').length,
			inProgress: vulnerabilityReport.findings.filter(f => f.status === 'in-progress').length
		};

		// Update last scan timestamp
		vulnerabilityReport.lastScan = new Date().toISOString();

		// Save vulnerability report to file
		fs.writeFileSync(
			vulnerabilityReportPath,
			JSON.stringify(vulnerabilityReport, null, 2)
		);

		logger.info(`Vulnerability scan completed in ${((Date.now() - startTime) / 1000).toFixed(2)}s`);
		logger.info(`Total findings: ${vulnerabilityReport.findings.length} (${vulnerabilityReport.summary.critical} critical, ${vulnerabilityReport.summary.high} high, ${vulnerabilityReport.summary.medium} medium, ${vulnerabilityReport.summary.low} low)`);

		// Output summary
		console.log('\nVulnerability Scan Summary:');
		console.log('============================');
		console.log(`Total vulnerabilities: ${vulnerabilityReport.findings.length}`);
		console.log(`  Critical: ${vulnerabilityReport.summary.critical}`);
		console.log(`  High: ${vulnerabilityReport.summary.high}`);
		console.log(`  Medium: ${vulnerabilityReport.summary.medium}`);
		console.log(`  Low: ${vulnerabilityReport.summary.low}`);
		console.log('\nStatus:');
		console.log(`  Open: ${vulnerabilityReport.summary.open}`);
		console.log(`  In Progress: ${vulnerabilityReport.summary.inProgress}`);
		console.log(`  Fixed: ${vulnerabilityReport.summary.fixed}`);
		console.log(`\nReport saved to: ${vulnerabilityReportPath}`);
	} catch (error) {
		logger.error('Error in vulnerability scan process:', error);
	}
}

// Run the vulnerability scan
runVulnerabilityScan();

module.exports = {
	runVulnerabilityScan,
	scanNpmDependencies,
	runDependencyCheck,
	scanDockerImages,
	scanServerEndpoints,
	CONFIG
};